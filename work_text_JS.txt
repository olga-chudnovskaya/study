Взаимодействие. Команды.

Вызывают модальное окно для:

alert - вывод (показывает сообщение)

prompt - ввода (показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.)

confirm - отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.

Результат – true, если нажата кнопка OK. В других случаях (если нажата кнопка «Отмена» или Esc с клавиатуры) – false.

Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.

На все указанные методы распространяются два ограничения:

1. Расположение окон определяется браузером. Обычно окна находятся в центре.
2. Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.
Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой функциональностью для взаимодействия с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.

Условное ветвление (инструкции)

if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.

Например:

let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year == 2015) alert( 'Вы правы!' );

Блок «else»(«иначе»)

Инструкция if может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно.

Например:

let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year == 2015) {
  alert( 'Да вы знаток!' );
} else {
  alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
}
Несколько условий: «else if»
Иногда, нужно проверить несколько вариантов условия. Для этого используется блок else if.

Например:

let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
В приведённом выше коде JavaScript сначала проверит year < 2015. Если это неверно, он переходит к следующему условию year > 2015. Если оно тоже ложно, тогда сработает последний alert.

Блоков else if может быть и больше. Присутствие блока else не является обязательным.

Условный («тернарный) оператор „?“

Синтаксис:

let result = условие ? значение1 : значение2;
Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.

Например:

let accessAllowed = (age > 18) ? true : false;

Циклы while и for

Для многократного повторения одного участка кода предусмотрены циклы.

while

Цикл while имеет следующий синтаксис:

while (condition) {
  // код
  // также называемый "телом цикла"
}
Код из тела цикла выполняется, пока условие condition истинно.

Например, цикл ниже выводит i, пока i < 3:

let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
Одно выполнение тела цикла по-научному называется итерация. Цикл в примере выше совершает три итерации.


do…while

Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:

do {
  // тело цикла
} while (condition);
Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.

Например:

let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным. На практике чаще используется форма с предусловием: while(…) {…}.


for
Более сложный, но при этом самый распространённый цикл — цикл for.

Выглядит он так:

for (начало; условие; шаг) {
  // ... тело цикла ...
}

break - прерывание цикла

Обычно цикл завершается при вычислении условия в false.

Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.


continue - переход к следующей итерации: continue

Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).

Её используют, если понятно, что на текущем повторе цикла делать больше нечего.



switch


Конструкция switch заменяет собой сразу несколько if.

switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}


Функции

Зачастую нам надо повторять одно и то же действие во многих частях программы.

Примеры встроенных функций – это alert(message), prompt(message, default) и confirm(question). Но можно создавать и свои.

Объявление функции
Для создания функций мы можем использовать объявление функции.

Пример объявления функции:

function showMessage() {
  alert( 'Всем привет!' );
}
Вначале идёт ключевое слово function, после него имя функции, затем список параметров в круглых скобках через запятую (в вышеприведённом примере он пустой) и, наконец, код функции, также называемый «телом функции», внутри фигурных скобок.

function имя(параметры) {
  ...тело...
}
Наша новая функция может быть вызвана по её имени: showMessage().

Например:

function showMessage() {
  alert( 'Всем привет!' );
}

showMessage();
showMessage();
Вызов showMessage() выполняет код функции. Здесь мы увидим сообщение дважды.

Этот пример явно демонстрирует одно из главных предназначений функций: избавление от дублирования кода.

Если понадобится поменять сообщение или способ его вывода – достаточно изменить его в одном месте: в функции, которая его выводит.


prompt('ЗАГОЛОВОК')
prompt('ЗАГОЛОВОК', 'НАЧАЛЬНОЕ ЗНАЧЕНИЕ')

alert('ТЕКСТ')

confirm("Ты уже перестала пить коньяк по утрам?")


if (x==1) variant1()


if (<условие>) {
    <вариант если выполняется>
} else {
    <вариант если не выполняется>
}


<условие> ? <вариант если выполняется> : <вариант если не выполняется>


while (<условие>) {
    <тело цикла>
}

do {
    <тело цикла>
} while (<условие>);


for (<назначение счетчика>; <условие>; <изменение счетчика>) {
    <тело цикла>
}

break;
continue;


switch (<переменная>) {
    case <значение1>:
        <действия1>
    break;
    case <значение2>:
    case <значение3>:
        <действия3>
    case <значение4>:
        <действия4>
    break;
    default:
        <действия0>
}

https://learn.javascript.ru/javascript-specials

function <имяФункции>(args) {
    <тело функции>
}


var func = function(args) {
    <тело функции>
}

func
func(...)

function func1() {...}
let func2 = func1;   - здесь функция
let func3 = func1(); - здесь возвращаемое значение от функции, а не она сама
func2() - все правильно
func3() - ошибка!


let a = (b) => b**2;

Объекты

Объекты же используются для хранения коллекций различных значений и более сложных сущностей. В JavaScript объекты используются очень часто, это одна из основ языка.
Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно.
Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:

let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"


Методы объекта, "this"
Метод - функция. Это способ организации данных.

Массив (список)

for ... in - по ключам
for ... of - по значениям


Методы

substring

Синтаксис
str.substring(indexA, [indexB])
Аргументы
indexA
целое число от 0 до длины строки-1
indexB
целое число от 0 до длины строки-1
Описание, примеры
Метод substring возвращает подстроку, начиная с позиции indexA до, но не включая indexB.

В частности:

Если indexA = indexB, возвращается пустая строка
Если indexB не указан, substring возвращает символы до конца строки
Если какой-то из аргументов меньше 0 или является NaN - он считается равным 0
Если какой-то из аргументов больше, чем длина строки - он считается равным длине строки
Если indexA > indexB, тогда substring ведет себя, как будто аргументы поменялись местами.

Рекурсия

Рекурсивная функция вызывает себя до тех пор, пока не будет выполнено условие

Рекурсивная функция может получать два входа: базовый случай (завершает рекурсию) или рекурсивный случай (возобновляет рекурсию).

 В некотором смысле рекурсия аналогична циклу. Оба выполняют один и тот же код несколько раз, и для обоих требуется условие (чтобы избежать бесконечного цикла или, скорее, бесконечной рекурсии в этом случае).

{
	[
		{
			[
				{
					...
				}
			]
		}
	]
}

JSON

LIFO последним пришел, первым ушел. CTEK
FIFO первым пришел, первым ушел. ОЧЕРЕДЬ

